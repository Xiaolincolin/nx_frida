const libName = "libgdtqone.so";


function base64Encode(arrayBuffer) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const bytes = new Uint8Array(arrayBuffer);
    let result = '', i;

    for (i = 0; i < bytes.length; i += 3) {
        let b1 = bytes[i];
        let b2 = i + 1 < bytes.length ? bytes[i + 1] : 0;
        let b3 = i + 2 < bytes.length ? bytes[i + 2] : 0;

        let triplet = (b1 << 16) + (b2 << 8) + b3;

        result += chars[(triplet >> 18) & 0x3F];
        result += chars[(triplet >> 12) & 0x3F];
        result += i + 1 < bytes.length ? chars[(triplet >> 6) & 0x3F] : '=';
        result += i + 2 < bytes.length ? chars[triplet & 0x3F] : '=';
    }

    return result;
}

function toBase64(ptr, len) {
    const buffer = Memory.readByteArray(ptr, len);
    console.log('aes hex:\n');
    console.log(hexdump(buffer, {length: len}))
    console.log('aes base64:\n');
    return base64Encode(buffer);
}

function hook_params_aes(baseAddr) {
    const sub_1F1C8_ptr = baseAddr.add(0x1F1C8);
    Interceptor.attach(sub_1F1C8_ptr, {
        onEnter(args) {
            const keyPtr = args[0]; // a1
            const ivPtr = keyPtr.add(176); // IV
            const plaintextPtr = args[1]; // a2
            const length = args[2].toInt32();

            console.log('[sub_1F1C8] AES Key:');
            console.log(hexdump(keyPtr, {length: 16}));

            console.log('[sub_1F1C8] IV:');
            console.log(hexdump(ivPtr, {length: 16}));

            console.log(`[sub_1F1C8] Plaintext (${length} bytes):`);
            console.log(hexdump(plaintextPtr, {length: length}));

            this.outputPtr = plaintextPtr;
            this.length = length;

        },

        onLeave(retval) {
            console.log('[sub_1F1C8] Encrypted Output (len=' + this.length + '):');
            // console.log(hexdump(this.outPtr, {length: this.len}));
            console.log(toBase64(this.outputPtr, this.length))
        }
    });
}

function hook_body(baseAddr) {
    // ËøôÊòØÊúÄÂêéjsonÁîüÊàêÁöÑÂú∞Êñπ
    const sub_1AFD0_ptr = baseAddr.add(0x1AFD0);
    Interceptor.attach(sub_1AFD0_ptr, {
        onEnter(args) {

        },
        onLeave(retval) {
            const out = this.context.x0;  // Êàñ args[1]
            const tag = Memory.readU64(out);
            let ptr, len;
            if ((tag & 1) === 0) {
                len = tag >>> 1;
                ptr = out.add(8);
            } else {
                len = Memory.readU64(out.add(8));
                ptr = Memory.readPointer(out.add(16));
            }
            try {
                const str = Memory.readUtf8String(ptr);  // ‰∏çÁªô lenÔºåFrida Ëá™Âä®ÈÅá 0 ÁªàÊ≠¢
                console.log("[sub_1AFD0] string:", str);
            } catch (e) {
                console.warn("[sub_1AFD0] Invalid UTF-8 at offset", e.offset || "?");
            }
        }
    });
}

function hook_aes(baseAddr) {
    const sub_1F0E0_ptr = baseAddr.add(0x1F0E0);
    Interceptor.attach(sub_1F0E0_ptr, {
        onEnter(args) {
            this.a1 = args[0];   // ÂéüÂßãÊòéÊñáÁªìÊûÑ‰Ωì
            this.a2 = args[1];   // AES ÂØÜÈí•
            this.a3 = args[2];   // IV ÊàñÈöèÊú∫Êï∞ÔºàÂèØÈÄâÊâìÂç∞Ôºâ

            // ËØªÂèñÊòéÊñáÈïøÂ∫¶
            const flag = this.a1.readU8();
            let len, dataPtr;
            if ((flag & 1) === 0) {
                len = flag >> 1;
                dataPtr = this.a1.add(8);
            } else {
                len = this.a1.add(8).readU32();
                dataPtr = this.a1.add(16).readPointer();
            }
            // ÊâìÂç∞ÂØÜÈí•ÔºàÂÅáËÆæ 16 Â≠óËäÇÔºâ
            console.log(`[sub_1F0E0] AES Key:`);
            console.log(hexdump(this.a2.readByteArray(16)));

            // ÂèØÈÄâÔºöÊâìÂç∞ IVÔºàÂ¶ÇÊûúÊòØ CBC Ê®°ÂºèÔºâ
            console.log(`[sub_1F0E0] IV:`);
            console.log(hexdump(this.a3.readByteArray(16)));

            // ËÆ∞ÂΩïÊòéÊñá
            const original = Memory.readByteArray(dataPtr, len);
            console.log(`[sub_1F0E0] enter Plaintext (${len} bytes): \n${hexdump(original, {length: len})}`);
        },

        onLeave(retval) {

        }
    });
}

function hook_17F2C(baseAddr) {
    // todo ËøΩË∏™ÊØè‰∏™Á´ØÂÄºÁöÑÊù•Ê∫êÁöÑÊù•Ê∫êÔºå‰æãÂ¶Çk1-k15
    const sub_17F2C = baseAddr.add(0x17F2C);
    Interceptor.attach(sub_17F2C, {
        onEnter(args) {
            this.a1 = args[2];   // ÂéüÂßãÊòéÊñáÁªìÊûÑ‰Ωì
            const flag = this.a1.readU8();
            let len, dataPtr;
            if ((flag & 1) === 0) {
                len = flag >> 1;
                dataPtr = this.a1.add(8);
            } else {
                len = this.a1.add(8).readU32();
                dataPtr = this.a1.add(16).readPointer();
            }
            if (len === 0) {
                return
            }

            const firstByte = Memory.readU8(dataPtr);
            console.log('firstByte:', firstByte)
            const original = Memory.readByteArray(dataPtr, len);
            console.log(`[hook_17F2C] enter (${len} bytes): \n${hexdump(original, {length: len})}`);
            const backtrace = Thread.backtrace(this.context, Backtracer.ACCURATE)
                .map(addr => DebugSymbol.fromAddress(addr).toString())
                .join("\n");
            console.log("[Call Stack]\n" + backtrace);
        },

        onLeave(retval) {

        }
    });
}


function hook_main() {
    const baseAddr = Module.findBaseAddress(libName);
    if (!baseAddr) {
        console.error("‚ùå Êú™ÊâæÂà∞Ê®°Âùó:", libName);
        return;
    }
    console.log('baseadd', baseAddr);
    hook_aes(baseAddr);
    hook_body(baseAddr);
    hook_params_aes(baseAddr);
}

function hook_system() {
    const libname = libName; // ÊîπÊàê‰Ω†ÁöÑ

    const waitForLib = () => {
        const m = Process.findModuleByName(libname);
        if (m) {
            console.log("üß¨ Found", libname, "at", m.base);
            hook_main();
        } else {
            setTimeout(waitForLib, 100); // ÈáçËØï
        }
    };

    waitForLib();

}


setImmediate(hook_system);
